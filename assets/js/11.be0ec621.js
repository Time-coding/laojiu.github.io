(window.webpackJsonp=window.webpackJsonp||[]).push([[11],{44:function(t,a,s){"use strict";s.r(a);var r=s(0),n=Object(r.a)({},function(){var t=this,a=t.$createElement,s=t._self._c||a;return s("ContentSlotsDistributor",{attrs:{"slot-key":t.$parent.slotKey}},[s("h1",{attrs:{id:"贪心算法"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#贪心算法","aria-hidden":"true"}},[t._v("#")]),t._v(" 贪心算法")]),t._v(" "),s("h2",{attrs:{id:"概念"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#概念","aria-hidden":"true"}},[t._v("#")]),t._v(" 概念")]),t._v(" "),s("p",[t._v("贪心算法不从整体最优上加以考虑，他所做出的是在某种意义上的局部最优解，需具备"),s("strong",[t._v("后无效性")]),t._v("。")]),t._v(" "),s("p",[t._v("贪心算法的基本思路是从问题的某一个初始解出发一步一步地进行，根据某个优化测度，每一步都要确保能获得局部最优解。每一步只考虑一个数据，他的选取应该满足局部优化的条件。若下一个数据和部分最优解连在一起不再是可行解时，就不把该数据添加到部分解中，直到把所有数据枚举完，或者不能再添加算法停止。")]),t._v(" "),s("h2",{attrs:{id:"贪心算法与动态优化的区别"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#贪心算法与动态优化的区别","aria-hidden":"true"}},[t._v("#")]),t._v(" 贪心算法与动态优化的区别")]),t._v(" "),s("p",[t._v("贪心算法的每一次操作都对结果产生直接影响，而动态规划则不是。"),s("br"),t._v("\n贪心算法对每个子问题的解决方案都做出选择，不能回退；动态规划则会根据以前的选择结果对当前进行选择，有回退功能。"),s("br"),t._v("\n动态规划主要运用于二维或三维问题，而贪心一般是一维问题。")]),t._v(" "),s("h2",{attrs:{id:"算法特性"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#算法特性","aria-hidden":"true"}},[t._v("#")]),t._v(" 算法特性")]),t._v(" "),s("ul",[s("li",[t._v("随着算法的进行，将积累起其它两个集合：一个包含已经被考虑过并被选出的候选对象，另一个包含已经被考虑过但被丢弃的候选对象。")]),t._v(" "),s("li",[t._v("有一个函数来检查一个候选对象的集合是否提供了问题的解答。该函数不考虑此时的解决方法是否最优。")]),t._v(" "),s("li",[t._v("还有一个函数检查是否一个候选对象的集合是可行的，也即是否可能往该集合上添加更多的候选对象以获得一个解。和上一个函数一样，此时不考虑解决方法的最优性。")]),t._v(" "),s("li",[t._v("选择函数可以指出哪一个剩余的候选对象最有希望构成问题的解。")]),t._v(" "),s("li",[t._v("最后，目标函数给出解的值。")]),t._v(" "),s("li",[t._v("为了解决问题，需要寻找一个构成解的候选对象集合，它可以优化目标函数，贪婪算法一步一步的进行。起初，算法选出的候选对象的集合为空。接下来的每一步中，根据选择函数，算法从剩余候选对象中选出最有希望构成解的对象。如果集合中加上该对象后不可行，那么该对象就被丢弃并不再考虑；否则就加到集合里。每一次都扩充集合，并检查该集合是否构成解。如果贪婪算法正确工作，那么找到的第一个解通常是最优的。")])]),t._v(" "),s("h2",{attrs:{id:"应用案例"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#应用案例","aria-hidden":"true"}},[t._v("#")]),t._v(" 应用案例")]),t._v(" "),s("h3",{attrs:{id:"买卖股票的最佳时机-ii"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#买卖股票的最佳时机-ii","aria-hidden":"true"}},[t._v("#")]),t._v(" 买卖股票的最佳时机 II")]),t._v(" "),s("p",[t._v("给定一个数组，它的第 i 个元素是一支给定股票第 i 天的价格。")]),t._v(" "),s("p",[t._v("设计一个算法来计算你所能获取的最大利润。你可以尽可能地完成更多的交易（多次买卖一支股票）。")]),t._v(" "),s("p",[t._v("注意：你不能同时参与多笔交易（你必须在再次购买前出售掉之前的股票）")]),t._v(" "),s("hr"),t._v(" "),s("ul",[s("li",[t._v("示例 1:"),s("br"),t._v("\n  输入: [7,1,5,3,6,4]"),s("br"),t._v("\n  输出: 7"),s("br"),t._v("\n  解释: 在第 2 天（股票价格 = 1）的时候买入，在第 3 天（股票价格 = 5）的时候卖出, 这笔交易所能获得利润 = 5-1 = 4 。"),s("br"),t._v("\n         随后，在第 4 天（股票价格 = 3）的时候买入，在第 5 天（股票价格 = 6）的时候卖出, 这笔交易所能获得利润 = 6-3 = 3 。")])]),t._v(" "),s("hr"),t._v(" "),s("ul",[s("li",[t._v("示例 2:"),s("br"),t._v("\n  输入: [1,2,3,4,5]"),s("br"),t._v("\n  输出: 4"),s("br"),t._v("\n  解释: 在第 1 天（股票价格 = 1）的时候买入，在第 5 天 （股票价格 = 5）的时候卖出, 这笔交易所能获得利润 = 5-1 = 4 。"),s("br"),t._v("\n         注意你不能在第 1 天和第 2 天接连购买股票，之后再将它们卖出。"),s("br"),t._v("\n    因为这样属于同时参与了多笔交易，你必须在再次购买前出售掉之前的股票。")])]),t._v(" "),s("hr"),t._v(" "),s("ul",[s("li",[t._v("示例 3:"),s("br"),t._v("\n  输入: [7,6,4,3,1]"),s("br"),t._v("\n  输出: 0"),s("br"),t._v("\n  解释: 在这种情况下, 没有交易完成, 所以最大利润为 0。")])]),t._v(" "),s("hr"),t._v(" "),s("h3",{attrs:{id:"解题思路"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#解题思路","aria-hidden":"true"}},[t._v("#")]),t._v(" 解题思路")]),t._v(" "),s("ul",[s("li",[t._v("股票买卖策略\n"),s("ul",[s("li",[t._v("对于单独交易日设今天价格P1，明天价格P2，则今天买入、明天卖出可赚取金额"),s("code",[t._v("P2-P1")]),t._v("(负值表示亏损)。")]),t._v(" "),s("li",[t._v("对于连续上涨交易日： 设此上涨交易日股票价格分别为P1、P2、...、Pn。则第一天买最后一天卖收益最大，即 "),s("code",[t._v("Pn-P1")]),t._v("；等价于每天都买卖，即"),s("code",[t._v("(P2-P1)+(P3-P2)+...+(Pn-P(n-1))")]),t._v(".")]),t._v(" "),s("li",[t._v("对于连续下降交易日： 则不买卖收益最大，即不会亏钱。")])])])]),t._v(" "),s("div",{staticClass:"language-javascript extra-class"},[s("pre",{pre:!0,attrs:{class:"language-javascript"}},[s("code",[s("span",{pre:!0,attrs:{class:"token comment"}},[t._v("/**\n* @param {number[]} prices\n* @return {number}\n*/")]),t._v("\n"),s("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("var")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token function-variable function"}},[t._v("maxProfit")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v("=")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("function")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),s("span",{pre:!0,attrs:{class:"token parameter"}},[t._v("prices")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("{")]),t._v("\n        "),s("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("let")]),t._v(" num"),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v("=")]),s("span",{pre:!0,attrs:{class:"token number"}},[t._v("0")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v("\n        "),s("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("for")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),s("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("let")]),t._v(" i"),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v("=")]),s("span",{pre:!0,attrs:{class:"token number"}},[t._v("0")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v("i"),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v("<")]),t._v("prices"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(".")]),t._v("length"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v("i"),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v("++")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("{")]),t._v("\n            "),s("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("if")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),t._v("prices"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("[")]),t._v("i"),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v("+")]),s("span",{pre:!0,attrs:{class:"token number"}},[t._v("1")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("]")]),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v("-")]),t._v("prices"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("[")]),t._v("i"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("]")]),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v(">")]),s("span",{pre:!0,attrs:{class:"token number"}},[t._v("0")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("{")]),t._v("\n                num"),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v("+=")]),t._v("prices"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("[")]),t._v("i"),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v("+")]),s("span",{pre:!0,attrs:{class:"token number"}},[t._v("1")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("]")]),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v("-")]),t._v("prices"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("[")]),t._v("i"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("]")]),t._v("\n            "),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("}")]),t._v("\n        "),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("}")]),t._v("\n        "),s("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("return")]),t._v(" num\n"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("}")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v("\n")])])]),s("h2",{attrs:{id:"参考"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#参考","aria-hidden":"true"}},[t._v("#")]),t._v(" 参考")]),t._v(" "),s("p",[s("a",{attrs:{href:"https://leetcode-cn.com/problems/best-time-to-buy-and-sell-stock-ii/solution/best-time-to-buy-and-sell-stock-ii-zhuan-hua-fa-ji/",target:"_blank",rel:"noopener noreferrer"}},[t._v("leetcode题解"),s("OutboundLink")],1)])])},[],!1,null,null,null);a.default=n.exports}}]);